// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc862.glitch.subsystems;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.BaseMotorController;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.team254.lib.util.DriveSignal;
import com.team254.lib.util.math.Rotation2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc862.glitch.Constants;
import org.usfirst.frc862.glitch.Robot;
import org.usfirst.frc862.glitch.RobotMap;
import org.usfirst.frc862.glitch.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;

import java.util.function.BiConsumer;
import java.util.function.Consumer;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import org.usfirst.frc862.util.DataLogger;


/**
 *
 */
public class DriveTrain extends Subsystem {

    enum Mode { voltage, velocity, test };
    Mode mode;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX left1 = RobotMap.driveTrainLeft1;
    private final WPI_TalonSRX left2 = RobotMap.driveTrainLeft2;
    private final WPI_TalonSRX left3 = RobotMap.driveTrainLeft3;
    private final WPI_TalonSRX right1 = RobotMap.driveTrainRight1;
    private final WPI_TalonSRX right2 = RobotMap.driveTrainRight2;
    private final WPI_TalonSRX right3 = RobotMap.driveTrainRight3;
    private final Encoder rightEncoder = RobotMap.driveTrainRightEncoder;
    private final Encoder leftEncoder = RobotMap.driveTrainLeftEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
//        setDefaultCommand(new TankDrive());
    }

    @Override
    public void periodic() {
        // in ticks / 100ms
        double left_vel = left1.getSelectedSensorVelocity(0);
        double right_vel = right1.getSelectedSensorVelocity(0);

        SmartDashboard.putNumber("Left Error", left1.getClosedLoopError(0));
        SmartDashboard.putNumber("left", left_vel);
        SmartDashboard.putNumber("left error", left1.getClosedLoopError(0));
        SmartDashboard.putNumber("right", right_vel);
        SmartDashboard.putNumber("right error", right1.getClosedLoopError(0));

        SmartDashboard.putNumber("left pos", left1.getSelectedSensorPosition(0));
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    protected static double native2ips(int native_speed) {
        final int CONV_100msTOsec = 1000 /100;
        return native_speed * CONV_100msTOsec / Constants.TICS_PER_ROTATION * Constants.WheelCircumference;
    }

    protected void eachMotor(Consumer<BaseMotorController> func) {
        func.accept(left1);
        func.accept(left2);
        func.accept(left3);
        func.accept(right1);
        func.accept(right2);
        func.accept(right3);
    }

    protected void setFollowMode(ControlMode mode) {
        eachMaster((m) -> m.set(mode, 0));
        eachSlave((m,s) -> s.follow(m));
    }

    protected void eachMaster(Consumer<TalonSRX> func) {
        func.accept(left1);
        func.accept(right1);
    }

    protected void eachSlave(Consumer<BaseMotorController> func) {
        func.accept(left2);
        func.accept(left3);
        func.accept(right2);
        func.accept(right3);
    }

    protected void eachSlave(BiConsumer<TalonSRX, BaseMotorController> func) {
        func.accept(left1, left2);
        func.accept(left1, left3);
        func.accept(right1, right2);
        func.accept(right1, right3);
    }

    protected void unsetFollowMode() {
        eachMotor((motor) -> {
            motor.set(ControlMode.Current, 0);
        });
    }

    public DriveTrain() {
        super();

        DataLogger.addDataElement("Left error",() -> left1.getClosedLoopError(0));
        DataLogger.addDataElement("Right error",() -> right1.getClosedLoopError(0));
        DataLogger.addDataElement("Left velocity",() -> left1.getSelectedSensorVelocity(0));
        DataLogger.addDataElement("Right velocity",() -> right1.getSelectedSensorVelocity(0));

        eachMaster((m) -> m.selectProfileSlot(0, 0));

        left1.setInverted(true);
        left1.setSensorPhase(true);
        right2.setInverted(true);
        right3.setInverted(true);

        eachMaster((m) -> m.configOpenloopRamp(Constants.openLoopRamp, Constants.TALON_TIMEOUT));

        /* set the peak and nominal outputs, 12V means full */
        eachMotor((baseMotorController) -> {
            baseMotorController.configNominalOutputForward(0, Constants.TALON_TIMEOUT);
            baseMotorController.configNominalOutputReverse(0, Constants.TALON_TIMEOUT);
            baseMotorController.configPeakOutputForward(1, Constants.TALON_TIMEOUT);
            baseMotorController.configPeakOutputReverse(-1, Constants.TALON_TIMEOUT);
        });

        setVoltageMode();
    }

    public Mode getMode() {
        return mode;
    }

    public void setVelocityMode() {
        setVelocityMode(Mode.velocity);
    }

    public void setVelocityMode(final Mode vmode) {
        setFollowMode(ControlMode.Velocity);
        eachMaster((m) -> {
            m.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, Constants.LOWGEAR_IDX, Constants.TALON_TIMEOUT);
            m.config_kP(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_P,Constants.TALON_TIMEOUT);
            m.config_kI(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_I, Constants.TALON_TIMEOUT);
            m.config_kD(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_D,Constants.TALON_TIMEOUT);
            m.config_kF(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_F,Constants.TALON_TIMEOUT);
            m.configAllowableClosedloopError(Constants.LOWGEAR_IDX, Constants.LOWGEAR_ALLOWED_DRIVE_ERROR, Constants.TALON_TIMEOUT);
            m.setSelectedSensorPosition(0, Constants.LOWGEAR_IDX, Constants.TALON_TIMEOUT);
        });

        eachMaster((m) -> {
            m.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, Constants.HIGHGEAR_IDX, Constants.TALON_TIMEOUT);
            m.config_kP(Constants.HIGHGEAR_IDX, Constants.HIGHGEAR_DRIVE_P,Constants.TALON_TIMEOUT);
            m.config_kI(Constants.HIGHGEAR_IDX, Constants.HIGHGEAR_DRIVE_I, Constants.TALON_TIMEOUT);
            m.config_kD(Constants.HIGHGEAR_IDX, Constants.HIGHGEAR_DRIVE_D,Constants.TALON_TIMEOUT);
            m.config_kF(Constants.HIGHGEAR_IDX, Constants.HIGHGEAR_DRIVE_F,Constants.TALON_TIMEOUT);
            m.setSelectedSensorPosition(0, Constants.HIGHGEAR_IDX, Constants.TALON_TIMEOUT);
            m.configAllowableClosedloopError(Constants.HIGHGEAR_IDX, Constants.HIGHGEAR_ALLOWED_DRIVE_ERROR, Constants.TALON_TIMEOUT);
        });

        // select slot based on current gear..
//        left1.selectProfileSlot(Constants.LOWGEAR_IDX, 0);
//        right1.selectProfileSlot(Constants.LOWGEAR_IDX, 0);

        mode = vmode;
    }

    public void setVoltageMode() {
        setFollowMode(ControlMode.PercentOutput);
        mode = Mode.voltage;
    }

    public void setTestMode() {
        unsetFollowMode();
        mode = Mode.test;
    }

    public void stop() {
        left1.stopMotor();
        right1.stopMotor();
    }

    public void upShiftBegin() {
        // reduce motor power...
    }

    public void upShiftEnd() {
//        left1.selectProfileSlot(Constants.HIGHGEAR_IDX, 0);
//        right1.selectProfileSlot(Constants.HIGHGEAR_IDX, 0);
        SmartDashboard.putString("DT PID", "upshifted");
        eachMaster((m) -> {
            m.config_kP(Constants.LOWGEAR_IDX, Constants.HIGHGEAR_DRIVE_P,Constants.TALON_TIMEOUT);
            m.config_kI(Constants.LOWGEAR_IDX, Constants.HIGHGEAR_DRIVE_I, Constants.TALON_TIMEOUT);
            m.config_kD(Constants.LOWGEAR_IDX, Constants.HIGHGEAR_DRIVE_D,Constants.TALON_TIMEOUT);
            m.config_kF(Constants.LOWGEAR_IDX, Constants.HIGHGEAR_DRIVE_F,Constants.TALON_TIMEOUT);
            m.configAllowableClosedloopError(Constants.LOWGEAR_IDX, Constants.HIGHGEAR_ALLOWED_DRIVE_ERROR, Constants.TALON_TIMEOUT);
        });
    }

    public void downShiftBegin() {
        // reduce motor power...
    }

    public void downShiftEnd() {
//        left1.selectProfileSlot(Constants.LOWGEAR_IDX, 0);
//        right1.selectProfileSlot(Constants.LOWGEAR_IDX, 0);
        SmartDashboard.putString("DT PID", "downshifted");
        eachMaster((m) -> {
            m.config_kP(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_P,Constants.TALON_TIMEOUT);
            m.config_kI(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_I, Constants.TALON_TIMEOUT);
            m.config_kD(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_D,Constants.TALON_TIMEOUT);
            m.config_kF(Constants.LOWGEAR_IDX, Constants.LOWGEAR_DRIVE_F,Constants.TALON_TIMEOUT);
            m.configAllowableClosedloopError(Constants.LOWGEAR_IDX, Constants.LOWGEAR_ALLOWED_DRIVE_ERROR, Constants.TALON_TIMEOUT);
        });
    }

    public void setVelocityIPS(double left, double right) {
        // todo scale left right correctly
        left1.set(ControlMode.Velocity, left);
        right1.set(ControlMode.Velocity, right);
        SmartDashboard.putNumber("drive left", left);
        SmartDashboard.putNumber("drive right", right);
    }

    public void setVelocity(double left, double right) {
        left1.set(ControlMode.Velocity, left);
        right1.set(ControlMode.Velocity, right);

//        left1.selectProfileSlot(0, 0);
//        right1.selectProfileSlot(0, 0);
        SmartDashboard.putNumber("drive left", left);
        SmartDashboard.putNumber("drive right", right);
    }

    public void setPower(double left, double right) {
        left1.set(ControlMode.PercentOutput, left);
        right1.set(ControlMode.PercentOutput, right);
        SmartDashboard.putNumber("drive left", left);
        SmartDashboard.putNumber("drive right", right);
    }

    public void set(double left, double right) {
        left1.set(mode == Mode.velocity ? ControlMode.Velocity : ControlMode.PercentOutput, left);
        right1.set(mode == Mode.velocity ? ControlMode.Velocity : ControlMode.PercentOutput, right);
        SmartDashboard.putNumber("drive left", left);
        SmartDashboard.putNumber("drive right", right);
    }

    public double getLeftDistanceInches() {
        // TODO scale correctly
        return left1.getSelectedSensorPosition(0);
    }

    public double getRightDistanceInches() {
        // TODO scale correctly
        return right1.getSelectedSensorPosition(0);
    }

    public double getLeftVelocityInchesPerSec() {
        // TODO scale correctly
        return left1.getSelectedSensorVelocity(0);
    }

    public double getRightVelocityInchesPerSec() {
        // TODO scale correctly
        return right1.getSelectedSensorVelocity(0);
    }

    public Rotation2d getGyroAngle() {
        return new Rotation2d();
    }

    public void setPower(DriveSignal drive) {
        SmartDashboard.putNumber("sp left", drive.getLeft());
        SmartDashboard.putNumber("sp right", drive.getRight());
        setPower(drive.getLeft(), drive.getRight());
    }

    public void setVelocity(DriveSignal drive) {
        setVelocity(drive.getLeft() * Constants.PHYSICAL_MAX_HIGH_SPEED_TICKS,
                drive.getRight() * Constants.PHYSICAL_MAX_HIGH_SPEED_TICKS);
    }

}

